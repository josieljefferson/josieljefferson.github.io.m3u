# ===================================================================
# 📌 WORKFLOW: deploy.yml (TURBO MODE - Otimizado para performance)
# ===================================================================

name: 🚀 Turbo Deploy to GitHub Pages

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:
  schedule:
    - cron: '0 11 * * *'  # 8h BRT / 11h UTC

# Configurações de ambiente otimizadas
env:
  NODE_ENV: production
  DEPLOY_ENV: github-pages
  NODE_VERSION: '20'
  PYTHON_VERSION: '3.10'

# Permissões granulares para melhor segurança
permissions:
  contents: write
  pages: write
  id-token: write
  actions: read

jobs:
  # Job de preparação e build
  prepare-and-build:
    name: 🏗️ Prepare & Build (Turbo Mode)
    runs-on: ubuntu-latest
    
    steps:
      # 1️⃣ Checkout otimizado
      - name: 🛒 Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          
      # 2️⃣ Configuração Python
      - name: 🐍 Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          
      # 3️⃣ Cache para Python
      - name: 🗄️ Cache Python dependencies
        uses: actions/cache@v3
        id: python-cache
        with:
          path: |
            ~/.cache/pip
            **/__pycache__
          key: ${{ runner.os }}-python-${{ hashFiles('**/requirements.txt') }}-${{ hashFiles('**/downloads_files.py') }}
          restore-keys: |
            ${{ runner.os }}-python-
            
      # 4️⃣ Instalar dependências Python
      - name: 📦 Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f "requirements.txt" ]; then
            pip install -r requirements.txt
          else
            echo "No requirements.txt found, installing common packages..."
            pip install requests beautifulsoup4 lxml
          fi
          
      # 5️⃣ Executar script de download (se existir)
      - name: ⬇️ Run downloads_files.py
        run: |
          if [ -f "downloads_files.py" ]; then
            python downloads_files.py
            if [ -f "downloaded_files.txt" ]; then
              echo "📄 Downloaded files:"
              cat downloaded_files.txt
            fi
          else
            echo "📝 downloads_files.py not found, skipping..."
            # Criar arquivo vazio para evitar erros
            touch downloaded_files.txt
          fi
          
      # 6️⃣ Configuração Node.js
      - name: ⎔ Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          
      # 7️⃣ Cache para Node.js
      - name: 🗄️ Cache Node.js dependencies
        uses: actions/cache@v3
        id: node-cache
        with:
          path: |
            node_modules
            ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('**/generate_metadata.js') }}
          restore-keys: |
            ${{ runner.os }}-node-
            
      # 8️⃣ Instalar dependências Node.js (se package.json existir)
      - name: 📦 Install Node.js dependencies
        run: |
          if [ -f "package.json" ]; then
            npm ci
          else
            echo "📝 package.json not found, skipping npm install..."
          fi
          
      # 9️⃣ Gerar metadata (se o script existir)
      - name: 📊 Generate metadata
        run: |
          if [ -f "generate_metadata.js" ]; then
            node --max-old-space-size=4096 generate_metadata.js
            if [ -f "files_metadata.json" ]; then
              echo "📊 Metadata generated:"
              ls -lh files_metadata.json*
            fi
          else
            echo "📝 generate_metadata.js not found, skipping..."
            # Criar metadata básica se não existir
            if [ ! -f "files_metadata.json" ]; then
              echo '{"generated": "'$(date)'", "files": []}' > files_metadata.json
            fi
          fi
          
      # 🔟 Otimização de assets
      - name: 🖼️ Optimize assets
        run: |
          set -e  # Para em caso de erro
          
          # Instalar ferramentas de otimização
          echo "📦 Installing optimization tools..."
          sudo apt-get update
          sudo apt-get install -y jpegoptim optipng pngquant webp
          
          # Criar diretório para assets otimizados se não existir
          mkdir -p optimized_assets
          
          # Otimizar JPEG/JPG
          echo "🖼️ Optimizing JPEG files..."
          find . -type f \( -iname "*.jpg" -o -iname "*.jpeg" \) -not -path "./.git/*" -print0 | \
            xargs -0 -P4 -I{} sh -c '
              file="{}"
              optimized="optimized_assets/${file#./}"
              mkdir -p "$(dirname "$optimized")"
              if command -v jpegoptim >/dev/null 2>&1; then
                jpegoptim --strip-all --max=85 --dest="$(dirname "$optimized")" "$file" || cp "$file" "$optimized"
              else
                cp "$file" "$optimized"
              fi
            ' || echo "⚠️ JPEG optimization completed with warnings"
            
          # Otimizar PNG
          echo "🖼️ Optimizing PNG files..."
          find . -type f -iname "*.png" -not -path "./.git/*" -print0 | \
            xargs -0 -P4 -I{} sh -c '
              file="{}"
              optimized="optimized_assets/${file#./}"
              mkdir -p "$(dirname "$optimized")"
              if command -v optipng >/dev/null 2>&1; then
                optipng -o2 -strip all -out "$optimized" "$file" || cp "$file" "$optimized"
              else
                cp "$file" "$optimized"
              fi
            ' || echo "⚠️ PNG optimization completed with warnings"
            
          # Copiar arquivos otimizados de volta (se houver)
          if [ "$(ls -A optimized_assets)" ]; then
            echo "📁 Copying optimized assets..."
            cp -r optimized_assets/* ./
          fi
          
          # Limpar diretório temporário
          rm -rf optimized_assets
          
          echo "✅ Asset optimization completed!"
          
      # 1️⃣1️⃣ Preparar arquivo index.html se não existir
      - name: 📄 Create default index.html
        run: |
          if [ ! -f "index.html" ] && [ ! -f "index.md" ]; then
            echo "📝 Creating default index.html..."
            cat > index.html << EOF
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Pages Site</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            max-width: 800px; 
            margin: 0 auto; 
            padding: 20px; 
            line-height: 1.6;
        }
        .header { 
            background: #f4f4f4; 
            padding: 20px; 
            border-radius: 5px; 
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🚀 GitHub Pages Site</h1>
        <p>Automatically deployed via GitHub Actions</p>
        <p><strong>Deploy Time:</strong> $(date)</p>
    </div>
    
    <h2>📁 Site Contents</h2>
    <ul id="file-list">
        <li>index.html (this file)</li>
    </ul>
    
    <script>
        // Listar arquivos disponíveis
        fetch('./files_metadata.json')
            .then(response => response.json())
            .then(data => {
                const fileList = document.getElementById('file-list');
                if (data.files && data.files.length > 0) {
                    fileList.innerHTML = '';
                    data.files.forEach(file => {
                        const li = document.createElement('li');
                        const a = document.createElement('a');
                        a.href = file.name;
                        a.textContent = file.name;
                        if (file.size) {
                            a.textContent += ` (${file.size})`;
                        }
                        li.appendChild(a);
                        fileList.appendChild(li);
                    });
                }
            })
            .catch(error => {
                console.log('No metadata file found or error loading it');
            });
    </script>
</body>
</html>
EOF
            echo "✅ Default index.html created"
          else
            echo "📄 Existing index file found, skipping creation"
          fi
          
      # 1️⃣2️⃣ Validar estrutura do site
      - name: 🔍 Validate site structure
        run: |
          echo "📁 Current directory structure:"
          find . -type f -not -path "./.git/*" -not -path "./node_modules/*" | head -20
          
          echo "📊 File count:"
          find . -type f -not -path "./.git/*" -not -path "./node_modules/*" | wc -l
          
          # Verificar se há arquivos para deploy
          if [ $(find . -type f -not -path "./.git/*" -not -path "./node_modules/*" | wc -l) -eq 0 ]; then
            echo "❌ ERROR: No files found for deployment!"
            exit 1
          fi
          
      # 1️⃣3️⃣ Upload do artifact
      - name: 📤 Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: .
          retention-days: 1

  # Job de deploy separado
  deploy:
    name: 🚀 Deploy to GitHub Pages
    runs-on: ubuntu-latest
    needs: prepare-and-build
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    
    permissions:
      pages: write
      id-token: write
      
    steps:
      # 1️⃣ Configurar Pages
      - name: ⚙️ Setup Pages
        uses: actions/configure-pages@v4
        
      # 2️⃣ Fazer deploy
      - name: 🚀 Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
        
      # 3️⃣ Notificação de status
      - name: 📢 Notify deployment status
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "✅ Deploy realizado com sucesso!"
            echo "🌐 URL: ${{ steps.deployment.outputs.page_url }}"
            echo "📅 Deploy Time: $(date)"
          else
            echo "❌ Falha no deploy!"
            echo "🔍 Verifique os logs para detalhes"
          fi

  # Job de limpeza pós-deploy
  cleanup:
    name: 🧹 Post-Deploy Cleanup
    runs-on: ubuntu-latest
    needs: [prepare-and-build, deploy]
    if: always()
    
    steps:
      - name: 🧹 Cleanup notifications
        run: |
          echo "🧹 Cleanup completed for workflow: ${{ github.workflow }}"
          echo "📊 Workflow status: ${{ needs.deploy.result }}"
          echo "⏰ Execution time: $(date)"
          echo "🎯 Repository: ${{ github.repository }}"
